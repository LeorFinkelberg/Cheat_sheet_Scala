\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Заметки. Практика использования и наиболее полезные конструкции языка \texttt{Scala}}

\author{\itshape Подвойский А.О.}

\date{}
\maketitle

\thispagestyle{fancy}

Здесь приводятся заметки по некоторым вопросам, касающимся машинного обучения, анализа данных, программирования на языках \texttt{Scala} и прочим сопряженным вопросам так или иначе, затрагивающим работу с данными.


%\shorttableofcontents{Краткое содержание}{1}

\tableofcontents

\section{Вызов функций и методов}

Математические функции определены в пакете \texttt{scala.math}. Их можно импортировать инструкцией

\begin{lstlisting}[
style = scala,
numbers = none
]
import scala.math._ // импорт всех элементов пакета
\end{lstlisting}

Здесь символ <<\verb|_|>> -- <<групповой>> символ, аналог <<\verb|*|>> в \texttt{Python}: \lstinline{from math import *}.

\remark{%
    При использовании пакета, имя которого начинается с префикса \texttt{scala.}, этот префикс можно опустить. Например, инструкция \texttt{import math.\_} эквивалентна инструкции \texttt{import scala.math.\_}, а вызов \texttt{math.sqrt(2)} эквивалентен вызову \texttt{scala.math.sqrt(2)}
}

\section{Метод apply}

В языке принято использовать синтаксис, напоминающий вызовы функций. Например, если \texttt{s} -- это строка, тогда выражение \texttt{s(i)} вернет $ i $-ый символ строки
\begin{lstlisting}[
style = scala,
numbers = none
]
"Fortran"(4)  // вернет `r` как 4-ый символ строки
// тоже самое с использованием метода `apply` "Fortran".apply(4)
\end{lstlisting}

Функции часто передаются методам в очень компактной форме записи. Например, чтобы вернуть количество символов верхнего регистра в строке можно воспользоваться конструкцией
\begin{lstlisting}[
style = scala,
numbers = none
]
// --- Scala ---
val s: String = "PythonTheBestLanguage"
s.count(_.isUpper)  // 4
\end{lstlisting}

На \texttt{Python} эту задачу можно решить так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# --- Python ---
# с помощью генератных выражений и генераторов списков
In[]: %timeit -n10 len(list(char for char in s if char.isupper()))
Out[]: 7.62 milis +/- 383 ns per loop (mean +/- std. dev. of 7 runs, 10 loops each)
In []: %timeit -n10 len([char for char in s if char.isupper()])
Out[]: 5.04 milis +/- 406 ns per loop (mean +/- std. dev. of 7 runs, 10 loops each)
# с помощью теоретико-множественных операций
In[]: from string import ascii_uppercase
In []: %timeit -n10 len(set(s).intersection(set(ascii_uppercase)))
Out[]: 7.5 milis +/- 812 ns per loop (mean +/- std. dev. of 7 runs, 10 loops each)
\end{lstlisting}

\section{Управляющие структуры и функции}

В \texttt{Java} или \texttt{C++} мы различаем \emph{выражения}, такие как \texttt{3 + 4}, и \emph{инструкции}, например \texttt{if}. Выражение имеет значение; инструкция выполняет действие. В \texttt{Scala} практически все конструкции имеют значения, то есть являются \emph{выражениями}. Это позволяет писать более короткие и более удобочитаемые программы.

\subsection{Условные выражения}

В \texttt{Scala} \verb|if/else| возвращает значение, а именно значение выражения, следующего за \texttt{if} или \texttt{else}. Например,
\begin{lstlisting}[
style = scala,
numbers = none
]
val x: Int = 10
val n = if (x > 0) 1 else -1  // тернарное выражение
\end{lstlisting}

В \texttt{Python} это выглядело бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
x = 10
n = 1 if (x > 0) else -1
\end{lstlisting}

В Scala \emph{каждое выражение имеет тип}. Например, выражение \verb|if (x > 0) 1 else -1| имеет тип \texttt{Int}, потому что обе ветви имеют тип \texttt{Int}. Типом выражения, способного возвращать значения разных типов, такого как \texttt{if (x > 0) "positive" else -1}, является супертип для обеих ветвей. В данном примере одна ветвь имеет тип \texttt{java.lang.String}, а другая -- тип \texttt{Int}. Их общий супертип называется \texttt{AnyVal}.

Может получиться так, что инструкция \texttt{if} не будет иметь значения. Например, в случае, когда \texttt{if (x > 0) 1}, а \texttt{x} отрицательный. Однако в Scala каждое выражение предполагает наличие какого-либо значения. Эта проблема была решена введением класса \texttt{Unit}, единственное значение которого записывается как \verb|()|\footnote{Эту комбинацию можно воспринимать как пустое значение и считать тип \texttt{Unit} аналогом типа \texttt{void} в Java или C++. Но, строго говоря, \texttt{void} означает отсутствие значения, тогда как \texttt{Unit} имеет единственное значение, означающее <<нет значения>> }. Инструкция \texttt{if} без ветви \texttt{else} эквивалентна инструкции
\begin{lstlisting}[
style = scala,
numbers = none
]
if (x > 0) 1 else ()
\end{lstlisting}

Многострочное выражение в интерактивной оболочке можно заключить в фигурные скобки
\begin{lstlisting}[
style = scala,
numbers = none
]
{
  if (x > 0) 1
  else
    if (x == 0) 0
    else -1
}
\end{lstlisting}

Если потребуется перенести длинную строку на другую строку, первая строка должна оканчиваться символом, который не может интерпретироваться как конец инструкции. Для этого подойдет любой оператор
\begin{lstlisting}[
style = scala,
numbers = none
]
s = s0 + (v - v0)*t + // оператор + сообщает парсеру, что это не конец
0.5*(a - a0)*t*t
\end{lstlisting}

На практике длинные строки можно обрамлять фигурными скобками
\begin{lstlisting}[
style = scala,
numbers = none
]
if (n > 0) {  // открывающая скобка в конце строки явно свидетельствует,
              // что инструкция будет продолжена на следующих строках
  r = r*n
  n -= 1
}
\end{lstlisting}

В языке Scala блок \verb|{}| содержит последовательность \emph{выражений} и сам считается выражением, результатом которого является результат \underline{последнего} выражения.

Это может пригодиться для инициализации значений \texttt{val}, когда требуется выполнить более одного действия. Например
\begin{lstlisting}[
style = scala,
numbers = none
]
import scala.math
val x: Int = 10
val x0: Int = 1
val y: Int = 24
val y0:Int = 50
val distance = { val dx = x - x0; val dy = y - y0; scala.math.sqrt(dx*dx + dy*dy) }
// вернет 27.51363298439521
\end{lstlisting}

Поскольку инструкции присвоения возвращают значение \texttt{Unit}, их нельзя объединять в цепочки
\begin{lstlisting}[
style = scala,
numbers = none
]
// -- Scala
x = y = 1 // Неправильно!
\end{lstlisting}

В Python можно
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# здесь просто x и y ссылаются на один и тот же объект целочисленного типа данных со значением 1
x = y = 1
\end{lstlisting}

\section{Ввод и вывод}

Чтобы вывести значение, используйте функцию \texttt{print} или \texttt{println}. Последняя добавляет символ перевода строки в конце. Имеется также функция \texttt{printf}, принимающая строку описания формата в стиле языка С
\begin{lstlisting}[
style = scala,
numbers = none
]
printf("CAE-package %s has %d cores", "Nastran", 32)
\end{lstlisting}

Прочитать строку, введенную в консоли с клавиатуры, можно с помощью функции \texttt{readLine}. Чтобы прочитать число, логическое или символьное значение, используйте \texttt{readInt}, \texttt{readDouble}, \texttt{readByte}, \texttt{readShort}, \texttt{readLong}, \texttt{readFloat}, \texttt{readBoolean} или \texttt{readChar}.

Метод \texttt{readLine}, в отличие от других, принимает строку приглашения к вводу
\begin{lstlisting}[
style = scala,
numbers = none
]
import scala.io.StdIn.readLine
import scala.io.StdIn.readInt
val name = readLine("Your name: ") // ввод имени
print("Your age: ")
val age = readInt()  // ввод возраста
printf("Hello, %s! Next year, you will be %d.", name, age+1)
// Hello, Leor! Next year, you will be 33.
\end{lstlisting}

\section{Циклы}

В Scala отсутствует прямой аналог цикла \texttt{for (инициализация;проверка;обновление)}. Если такой цикл потребуется, у вас есть два варианта на выбор -- использовать цикл \texttt{while} или инструкцию \texttt{for}, как показано ниже
\begin{lstlisting}[
style = scala,
numbers = none
]
val n:Int = 10 // константа
var r: Int = 1 // переменная со значением по умолчанию
for (i <- 1 to n)
    r = r*i
printf("Result: %d", r) // Result: 3628800
\end{lstlisting}

В Python эта задача решалась бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
n = 10
r = 1
for i in range(1,n+1):
    r *= i
print(f'Result: {r}')  # Result: 3628800
\end{lstlisting}

Вызов \texttt{1 to n} вернет объект \texttt{Range}, представляющий числа в диапазоне от 1 до \texttt{n} (включительно).

Конструкция
\begin{lstlisting}[
style = scala,
numbers = none
]
for (i <- expr)
\end{lstlisting}
обеспечивает последовательное присваивание переменной \texttt{i} всех значений выражения \texttt{expr} справа от \texttt{<-}. Порядок присвоения зависит от типа выражения. Для коллекций, таких как \texttt{Range}, присвоит переменной \texttt{i} каждое значение по очереди.

Перед именем переменной в цикле \texttt{for} не требуется указывать \texttt{val} или \texttt{var}. Тип переменной соотвествует типу элементов коллекции. Область видимости переменной цикла ограничивается телом цикла.

Для обхода элементов строки или массива зачастую нужно определить диапазон от 0 до $ n - 1 $. В этом случае используйте метод \texttt{until} вместо \texttt{to}. Он возвращает диапазон, не включающий верхнюю границу. Например
\begin{lstlisting}[
style = scala,
numbers = none
]
val s: String = "Hello"
var sum: Int = 0
for (i <- 0 until s.length)
  sum += s(i)
\end{lstlisting}

В действительности в данном примере нет необходимости использовать индексы. Цикл можно выполнить непосредственно по символам
\begin{lstlisting}[
style = scala,
numbers = none
]
var sum: Int = 0
for (ch <- "Hello")
  sum += ch
\end{lstlisting}

Как и в Python. В Python тоже можно перебирать элементы последовательности прямо в цикле без индексов. В Scala циклы используются те так часто, как в других языках. Значения в последовательностях зачастую можно обрабатывать, применяя функцию сразу ко всем элементам, для чего достаточно произвести единственный вызов метода.

В Scala нет инструкций \texttt{break} или \texttt{continue} для преждевременного завершения цикла. Но как же быть, если это потребуется? Есть несколько вариантов:
\begin{enumerate}
	\item Использовать логическую переменную управления циклом,
	
	\item Используйте вложенные функции -- при необходимости можно выполнить инструкцию \texttt{return} в середине функции,
	
	\item Используйте метод \texttt{break} объекта \texttt{Breaks}
	\begin{lstlisting}[
	style = scala,
	numbers = none
	]
	// здесь передача управления за пределы цикла выполняется путем возбуждения и перехвата исключения, поэтому избегайте пользоваться этим механизмом, когда скорость выполнения критична
	import scala.util.control.Breaks._
	breakable {
	  for (...) {
	    if (...) break; // выход из прерываемого блока
	      ...
	  }
	}
	\end{lstlisting}
\end{enumerate}

\subsection{Расширенные циклы for и for-генераторы}

В предыдущем разделе была представлена базовая форма цикла \texttt{for}. Однако эта конструкция намного богаче, чем в Java или C++. В заголовке цикла \texttt{for} допускается указывать несколько \emph{генераторов} в форме \textit{переменная <- выражение}, разделяя их <<;>>

\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[
	style = scala,
	numbers = none	
	]
// --- Scala
// несколько генераторов
for (i <- 1 to 3; j <- 1 to 5)
  print(f"${10*i + j} ")
	\end{lstlisting}
\end{minipage}
\hspace*{2mm}
\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[
	style = ironpython,
	numbers = none	
	]
# --- Python
# вложенные циклы
for i in range(1, 3+1):
    for j in range(1, 5+1):
        print(f'{10*i+j} ')
	\end{lstlisting}
\end{minipage}

Что касается форматирования, то можно использовать конструкции с f-строками. Пример
\begin{lstlisting}[
style = scala,
numbers = none
]
import scala.io.StdIn.readLine
import scala.io.StdIn.readInt

val package_name = readLine("Enter package's name: ")
print("Enter number of cores: ")
val n_cores = readInt()
print(f"CAE-package: ${package_name}, number of cores: ${n_cores}") // f-строка
\end{lstlisting}

Управлять форматом вывода чисел можно так
\begin{lstlisting}[
style = scala,
numbers = none
]
val n: Double = 0.345345345345
print(f"This is a number: ${n}%.3f") // This is a number: 0,345
\end{lstlisting}

Каждый генератор может иметь \emph{ограничитель} -- логическое условие с предшествующим ему ключевым словом \texttt{if}

\begin{minipage}[t]{0.48\textwidth}
	\begin{lstlisting}[
	style = scala,
	numbers = none
	]
// --- Scala
for (i <- 1 to 3; j <- 1 to 3 if i != j)
  print(f"${10*i + j} ")
	\end{lstlisting}
\end{minipage}
\hspace*{4mm}
\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[
	style = ironpython,
	numbers = none
	]
# --- Python
for i in range(1,3+1):
    for j in range(1,3+1):
        if i != j:
            print(f'{10*i + j} ', end=' ')
	\end{lstlisting}
\end{minipage}

Допускается любое количество \emph{определений}, вводящих переменные для использования внутри цикла

\begin{lstlisting}[
style = scala,
numbers = none
]
// --- Scala
for (i <- 1 to 3; from = 4 - i; j <- from to 3)
  print(f"${10*i + j} ")
  // 13 22 23 31 32 33
\end{lstlisting}

На Python эта задача могла бы быть решена так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
for i in range(1,3+1):
    frm = 4 - i
	for j in range(frm,3+1):
	    print(f'{10*i + j} ')
# 13 22 23 31 32 33
\end{lstlisting}








%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{hostmann:scala-2013}{{\emph{Хостаманн К.} Scala для нетерпеливых. -- М.: ДМК Пресс, 2013. -- 408~с. }
\end{thebibliography}

\end{document}
